---
layout: post

title: "单元测试"
date: 2020-09-19
categories: [Agile]
tags: [AGILE-TEST]
column: AGILE-TEST
sub-tag: "common"

author: "袁慎建"

brief: "
单元测试是人们经常在软件开发中谈论的话题，它也是我整个编程生涯中一直很熟悉的一个术语。但它跟大多数软件开发术语一样，定义很不明确。而且我看到一个现象：人们在发现它的定义比实际中更加严格时就会产生困惑。
"

---

* content
{:toc}


单元测试是人们经常在软件开发中谈论的话题，它也是我整个编程生涯中一直很熟悉的一个术语。但它跟大多数软件开发术语一样，定义很不明确。而且我看到一个现象：人们在发现它的定义比实际中更加严格时就会产生困惑。

![](https://martinfowler.com/bliki/images/unitTest/sketch.png)

虽然我之前已经做过大量的单元测试，但我公开谈论它是在我开始与Kent Beck合作并使用Xunit系列的单元测试工具之后。（实际上，我有时觉得能够很好形容这种测试风格的术语是“xunit testing。”）单元测试也成为[极限编程](https://martinfowler.com/bliki/ExtremeProgramming.html) (XP)的一项标志性活动，并迅速促成了[测试驱动开发](https://martinfowler.com/bliki/TestDrivenDevelopment.html)（led quickly to TestDrivenDevelopment）。


起初，我对XP使用单元测试存有明确的担忧。我跟Usenet讨论小组的讨论记忆犹新，在该小组中，我们这些XPer[译注1]因滥用“单元测试”这个术语而受到测试专家的谴责。我们向专家询问了他的定义，他的回答是：“在我的培训课程的第一个早晨，我就提到了单元测试的24种不同定义。”

尽管对单元测试的理解有很多差异，但还是存在一些共同点。首先，单元测试是低层级的，只关注软件系统的小部分的代码。其次，这些日子程序员自己使用常规工具编写单元测试 -- 唯一的区别是使用不同类型的单元测试框架[注1]。 最后，单元测试运行起来应该要比其他类型的测试快得多。


了解了共同点，来看看有哪些差异。差异之一是每个人所认为的单元是不一样的。面向对象设计倾向于将类视为单元，过程式或函数式编程可能会将单个函数视为单元。但也的确存在这种情况：团队出于更好地理解系统及其测试的目的而决定如何去定义一个单元。 尽管我一开始认为单元是一个类，但我也经常将一堆紧密相关的类视为一个单元。我很少将类中方法的子集视作一个单元。 然而，怎么定义它其实也不重要。


### 孤立型（Solitary） 或 社交型（Sociable）?
一个更重要的区别是你要测试的单元应该是社交型（Sociable）的还是孤立型（Solitary）的[注2]。 假设你正在测试订单类的价格方法。 价格方法需要调用产品和客户类中的某些函数。如果你希望单元测试是孤立型（Solitary）的，你就不要调用真实的产品或客户类，因为客户类中的错误会导致订单类的测试失败。此时，你需要引入[测试替身]({{site.url | append: '/test-double'}})（[TestDoubles](https://martinfowler.com/bliki/TestDouble.html)）来替换掉产品类和客户类。


但是，并非所有单元测试人员都使用孤立型（Solitary）的单元测试。我们在90年代开始进行xunit测试时都不会尝试编写孤立型（Solitary）的单元测试，除非被测试对象不方便与它的合作者进行交互（例如远程信用卡验证系统）。即便它会导致相邻测试失败，我们也不难发现错误。因此，我们认为社交型（Sociable）的测试并不会在实践中引发问题。

的确，我们因使用“单元测试”一词而受到批评的原因之一是我们使用了社交型（Sociable）单元测试。 我认为“单元测试”一词很合适，因为这些测试是对单个单元行为的测试。 我们在编写测试时假设除该单元以外的所有其他功能都能正常工作。


随着xunit测试在2000年代变得越来越流行，至少对于某些人来说，孤立型（Solitary）测试的概念又回来了。我们看到了支持模拟的Mock对象和框架的兴起。也诞生了两种xunit测试流派，我称之为古典风格和模拟（mockists）风格。两种风格之间的区别之一是，模拟主义者坚持孤立型（Solitary）的单元测试，而古典主义者则喜欢社交型（Sociable）的单元测试。 今天，我理解并尊重这两种风格的xunit测试人员（我个人仍然保留古典风格）。


当被测对象很难与其协作者交互时，即使像我这样的古典测试人员也难免会使用测试替身（Test double）。比如，与远程服务交互时，测试替身能够很好地消除不确定性。一些古典主义xunit测试人员甚至还提倡任何与外部资源（例如数据库或文件系统）有交互的场景都应该使用测试替身。他们这么说一方面是考虑到外部资源不确定性的风险，另外则是测试的运行速度。我觉得这是一条实用的建议，不过我不会将其视作一条绝对的法则。如果与外部资源的交互足够稳定且足够快，那就不必引入测试替身了。


### 速度

单元测试的一些共同属性是 -- 范围小、由程序员自己编写，并且速度很快，这就意味着在编码过程中，单元测试是可以频繁地被运行。 实际上，这是[自测试代码]({{site.url | append: '/self-testing-code'}})（[SelfTestingCode](https://martinfowler.com/bliki/SelfTestingCode.html)）的关键特征之一。在这种情况下，代码有任何更改，程序员都要运行单元测试。 每当我编写了值得编译的代码时，我可能会每分钟运行好几次单元测试。这样做我就能很快知道我是否破坏了某些功能。如果我在最后一次更改中引入了缺陷，我就能很容易发现该错误，因为我运行测试非常频繁。


如果你也频繁地运行单元测试，可能不会每次运行所有单元测试。通常，你只需要运行那些跟你当前代码相关的单元测试。一样的道理，你得权衡测试的深度[译注2]和运行测试套件所花费的时间。我把这个测试套件叫做编译套件（compile suite），因为它是我在想要编译时就运行的套件，即使使用像Ruby这样的解释型语言也是如此。


如果你使用了持续集成（Continuous Integration），你需要在集成后运行测试套件。 我把这种套件命名为提交套件（commit suite），它通常包含了所有的单元测试，还可能包括一些[BroadStackTests](https://martinfowler.com/bliki/BroadStackTest.html)。作为程序员，你应该每天运行几次提交套件，而且要在对版本控制进行任何共享提交之前，但也应在其他任何时候（休息或参加会议）运行。 提交套件越快，你运行它的频率就越高。 [注3]


不同的人对于单元测试及其测试套件的速度有不同的标准。 戴维·海尼迈尔·汉森（David Heinemeier Hansson）对花费数秒钟的编译套件和花费数分钟的提交套件感到满意。 加里·伯恩哈特（Gary Bernhardt）觉得这太慢了，坚持使用300ms左右的编译套件。而丹·博达特（Dan Bodart）希望他的提交套件在10秒以内。


我认为没有绝对的标准答案。就我个人而言，我觉得亚秒级或几秒钟的编译套件之间的没什么太大差异。我喜欢Kent Beck的经验法则，即提交套件运行时间应该控制在十分钟以内。其实，真正的重点是你的测试套件应该运行得足够快，否则你可能不太愿意去频繁地运行它们。一旦频繁运行，当它们检测到错误时，你就能很快定位到错误。


#### 注释
1. 注1：我之所以说“这些日子”，是因为XP肯定已经改变了这一点。 在世纪之交的辩论中，XPer为此受到强烈批评，因为普遍的观点是程序员永远不要测试自己的代码。 一些商店有专门的单元测试人员，他们的全部工作是为开发人员早期编写的代码编写单元测试。 这样做的原因包括：人们对测试自己的代码有概念上的盲目性，程序员不是优秀的测试人员，并且在开发人员和测试人员之间建立对抗关系是件好事。 XPer的观点是，程序员至少在单元级别上可以学习成为有效的测试员，并且如果你隔离出一个独立的测试小组，那么测试给你的反馈循环将会变慢很多。 Xunit在这里起着至关重要的作用，它专门帮助为了减少程序员编写测试时遇到的阻力。
2. 注2：杰伊·菲尔德（Jay Fields）提出了“孤立型（Solitary）”和“社交型（Sociable）”的术语
3. 注3：如果你有有用的测试，但是所花的时间比提交套件要运行的时间长，那么应该构建一个部署流水线（[DeploymentPipeline](https://martinfowler.com/bliki/DeploymentPipeline.html)），将较慢的测试放在流水线的后期。
4. 译注1：XPer，代指极限编程实践者、推崇者、推动者、热衷者等。
5. 译注2：这里的测试深度是指需要运行相关测试的量，因为当要运行测试要跟当前工作代码相关时，才能帮助发现问题。另外运行越多，时间就会越慢，所以要做一个平衡。

#### 声明
本文翻译自Martin Fowler的文章*UnitTest*：

- 原文链接： [UnitTest](https://martinfowler.com/bliki/UnitTest.html)
- 原文作者： [Martin Fowler](https://martinfowler.com/)
- 发表时间： 2014年5月2日
