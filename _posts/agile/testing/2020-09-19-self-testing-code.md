---
layout: post

title: "自测试代码"
date: 2020-09-19
categories: [Agile]
tags: [AGILE, AGILE-TESTING]
column: AGILE-TESTING
sub-tag: "common"

author: "袁慎建"

brief: "
自测试代码是我在重构中使用的名称，它指的是*在开发软件系统功能的同时编写全面自动化测试的做法*。做好了这一点，你就可以调用一个命令来执行测试 -- 并且你很自信这些测试将会暴露任何隐藏在代码中的错误。
"

---

* content
{:toc}


自测试代码是我在重构（[Refactoring](https://martinfowler.com/books/refactoring.html)）中使用的名称，它指的是*在开发软件系统功能的同时编写全面自动化测试的做法*。做好了这一点，你就可以调用一个命令来执行测试 -- 并且你很自信这些测试将会暴露任何隐藏在代码中的错误。


![](https://martinfowler.com/bliki/images/selfTestingCode/sketch.png)

我是在OOPSLA会议上第一次听到“贝达拉”戴夫·托马斯（[ "Beddara" Dave Thomas](http://www.davethomas.net/)）提出这个想法，他说每个对象都应该能够自我测试。当时听到这个概念后，我就陷入了冥想：我只用键入一个命令，然后我的整个软件系统就会开始自测试。有点类似于启动电脑后就能看到内存测试。很快，我在自己的项目中探索了这种方法，并收获颇丰。几年后，我与肯特·贝克（Kent Beck）合作时发现他也做了同样的事情，但是比我做的要复杂得多。而这就发生在Kent（和Erich Gamma）发明JUnit之前不久 -- JUnit这个工具后来为自测试代码（及其姐妹：TestDrivenDevelopment）的思想和实践夯实了基础。


当你可以对代码库运行一系列自动化测试时，就意味着你拥有了自测试代码。并且你能确信一点：如果测试通过，你的代码将没有任何明显的缺陷。我对它的一种理解是，除了构建你的软件系统，你应该同时构建一个能够检测系统内部任何错误的错误检测器。如果团队中有人不小心引入了错误，检测器就会报警。通过频繁地运行测试套件（每天至少几次），你可以在错误被引入后立即检测到它们，这样你就只用查看最近的更改即可，查找起来会容易得多。没有可工作的代码和确保其正常工作的测试的编码过程是不完整的。我们的态度是假定任何未经测试的重要代码都将会被破坏。

自测试代码是持续集成的关键部分，甚至我认为，如果你没有自测试代码，意味着你不是在做持续集成（[Continuous Integration](https://martinfowler.com/articles/continuousIntegration.html)）。作为持续集成的支柱，它也是持续交付（[Continuous Delivery](https://martinfowler.com/delivery.html)）的必要组成。

自测试代码的一个明显好处是，它可以大大减少错误进入到生产环境中。这样做的核心点是能建立一种测试文化 -- 开发人员自然而然地认为编写代码和编写测试是不可分割的。

自测试代码最大的好处不是仅仅有效减少了生产环境的错误，而是大大增强了你更改系统的信心。旧的代码库通常是一个可怕的东西，因为开发人员害怕更改那些已经工作的代码。甚至连修复错误都很危险，因为新引入的错误可能比修复掉的错误还多。在这种情况下，不仅添加新功能非常缓慢，你还不敢重构系统，导致技术债持（[TechnicalDebt](https://martinfowler.com/bliki/TechnicalDebt.html)）续增加，陷入不断恶化的螺旋式增长，其中每一个更改都会加深人们对更改的恐惧。

使用自测试代码后情况就不同了。有了它，人们对修复小问题来清理代码的安全性充满信心。因为错误检测器会在你犯了一个错误（或者更确切地说是“当我犯错时”）时及时提示你，然后你就可以快速进行恢复并继续。有了这个安全网，你就可以花时间来优化代码，并最终进入良性循环，此后你添加新功能的速度就会越来越快。

这些好处通常与测试驱动开发（[TestDrivenDevelopment](https://martinfowler.com/bliki/TestDrivenDevelopment.html)，TDD）有一定的关系，但是将TDD和自测试代码的概念分开也很有必要。我认为TDD是一种特殊的做法，其好处包括了产生自测试代码。TDD是一种很好的方式，它还是我非常喜欢的一项技术。不过你也可以在编写代码后再编写测试来生成自测试代码 -- 尽管在测试通过之前，你不能认为完工了。自我测试代码的重点是你要有测试，而不是你如何产生这些测试。

团队实施自测试代码的一项重要行为表现是对生产错误的反应。当出现生产错误的后，他们会先编写一个能暴露该错误的测试，然后才尝试对其进行修复。通常，要编写的测试可能是一系列测试，这些测试会逐渐缩小范围，直到达到触发该错误的[单元测试]({{site.url | append: '/unit-test'}})（[UnitTest](https://martinfowler.com/bliki/UnitTest.html)）。这是一种实用的调试技术，它能够确保错误一经修复后将保持不变。团队通常还会利用这个错误作为启发来寻找类似缺失的测试。我们态度应该是 -- 任何错误不仅是代码中的错误，它还意味着测试的缺失。

如今，我们越来越多地看到自测试的另一个维度 -- 更强调在生产环境进行监视。配合持续交付（[ Continuous Delivery ](https://martinfowler.com/delivery.html)），团队可以快速将新版本的软件部署到生产环境中。在这种情况下，团队会投入更多精力来发现生产环境中的错误，并通过部署新的已修复版本或回滚到已知的良好版本来快速修复它们。


#### 声明
本文翻译自Martin Fowler的文章*SelfTestingCode*：

- 原文链接： [SelfTestingCode](https://martinfowler.com/bliki/SelfTestingCode.html)
- 原文作者： [Martin Fowler](https://martinfowler.com/)
- 发表时间： 2014年5月1日
- 首发时间： 2005年5月5日
